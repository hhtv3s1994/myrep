bnf语法  生成式       树的搜索顺序――深搜

所有符号都是有值的

对于{}  先从前面分辨结构类型，再进去读取

语法分析检查是不严格检查，总会有漏洞（比如过多通过的值，错误的参数类型），之后通过语义规定来限制 能输入的语句

这也就说明了语法分析可以稍微宽松点，语义上要比较严格限制语句的格式，不然错误的语句也会被错误地翻译成目标语言


设计时不用太死板，非要用汇编，多维护几张表， 对于表达式类可以直译，对于创建的变量可以维护一个变量表和一个动态增改的变量数组。？？？  中缀的表达式。。。
比较符号怎么算？ 布尔如何实现？


右值都是存寄存器，就算只有一个变量。

做个最简单的实现再增加功能

变量的值是动态的，找到所有变量赋值语句

类型是值和操作的集合


关于动态类型：分配的内存长度不能在编译时确定？ 可以用堆
a[n]可以是动态长度的数组吗？不硬编码？

if 语句长成这个样子，则把它翻译成那个样子的目标语言（一般是虚拟机或者汇编机器语言），虚拟机就是模拟内存和寄存器，内存是数组，有不同分区。。。寄存器则是几个变量，提供给虚拟机执行中的判断用，比如堆栈指针eip指针，比较用寄存器     
 寄存器的占用和释放--

虚拟机用一个循环不断地读取数组中的指令，根据不同的命令触发不同的程序。 如修改内存，读取内存，增加内存数据， 跳转读取处
标准库应该用原语言实现 Int中断

但是函数中使用的都是动态地址，只有运行时才知道具体值，普通的时候是用栈指针和寄存器来指示
寄存器是分配给语句，语句确定，寄存器就确定



寄存器的功能;  如何分配的？

中缀表达式的求法：符号优先级

基础单位是语句   语句的下层是表达式  是按照深搜顺序执行每条语句
寄存器的使用以语句为单位，  在语句运行之后。。寄存器恢复使用
表达式值

参数和局部变量开辟堆栈
new语句开辟堆  堆需要指针吗？还是特殊算法？

变量名就是地址的引用

定义型语句开辟空间，  其他语句直接翻译成代码

需要遍历所有的变量，在程序的开头就分配堆栈或者堆

变量的地址是用堆栈相对值

堆地址的访问，有无偏移，是否需要指针。。。。需要维护符号表，保存变量地址，类型（长度），结构。。。。 函数符号表

参数调用时，在程序内部是如何的地址，push进去之后如何使用？  需要维护参数表吗？相对地址
（函数调用要先push   然后把参数作为堆栈第一个局部变量  ） ,相对地址，动态算出


return 0 ;

关于类和对象，维护一个类表？



观察c++怎么转汇编的？

多选一   |  switch
重复{}    for while
选择

分号  和加号有区别吗？

下层递归上层或者同层？  

层其实只是为了决定语句的执行顺序，从最底层深搜

每次读一个token 根据前后文关系判断到底是属于什么类型 是   if then

上层结构   对下层分支的遍历   一直到最下层语句才顺序翻译  如何分层，加和乘
树形父子结构还是平行结构
表达式的临时值都用寄存器？

每个语句分号后释放一个寄存器？

寄存器保存和恢复

内存的动态地址  地址的指针  全局指针  堆栈指针 bp+10

语句翻译顺序

维护符号表   分配寄存器和地址
一个函数中有多少个变量，分配多少空间  


表达式结果在寄存器中    寄存器恢复使用占用    指针寄存器

赋值结果

语句   

int指令
io指令



节点层次：子节点   节点对象的信息，包含的变量名（作用域），链接到上层左用域的local
节点的文本段，节点的格式...

next.parse   不同类型的节点 
 表达式节点：存在值（value）   函数调用，存在值（value） 应该用寄存器保存

声明型语句遍历，加入到本地作用域 



程序   
函数声明 函数名 返回值类型 参数类型
变量声明：变量名，类型  分配的内存

引用型变量  自己的地址和大小是固定的，但保存的值是不固定的 有特殊的使用方法
普通变量： 地址和大小是固定的
强制类型转换会发生什么？地址和大小会变吗？
类型转换不影响右值，只是提高位后赋给右值
对象的强制类型转换会发生什么？  什么都不发生，只有转型才能调用父接口，不然编译不通过

隐式转换：算数时，低转高  赋值时，右转左   调用时，实转形（参数校验不过吧）
返回值转类型

 



函数调用（）

二元
一元表达

运算符

运算符优先级（最高优先级应该是最底层子元素）  

复合表达式拆成表达式树    复合表达式  =简单表达式 |  简单+运算符+(复合)
表达式如何顺序结合？ 


