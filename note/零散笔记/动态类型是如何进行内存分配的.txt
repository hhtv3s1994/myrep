垃圾回收   无引用的对象

原则上来说，堆/栈上分配的内存，包括全局区 ，都是按照语句顺序来加入的，一般都是紧紧相邻

栈存在收缩，   而堆则可以释放出一块空区（堆本身是排序树？排的是什么？空间大小？根据加入的数据，会把其中的数据进行挪动？   还是不挪动，只排序内容大小，把小的加入到空隙？）  堆地址是否可变？

类似c语言，用栈的情况比较多 ，栈在函数执行时加入数据，函数退出时释放数据，是很灵活的。

js之类的语言可能会倾向把引用类型分配到堆，把基本类型分配到栈？


什么是作用域？   在编译时确认哪些变量是同一变量？分配同样的内存    还是运行时确定？
总之就是认出同名变量

什么是函数定义：就是内存一串代码      定义本身不执行，要使用的时候jmp/call过去
什么是变量定义：名字=地址，类型=长度    然而动态语言中地址和长度好像都可以变？





为什么内存碎片多程序效率就会降低，读取内存是个什么过程？虚拟内存映射，已经加载的内存页有哪些，全局变量会一开始被加入进来吗？   栈肯定是一直在的？  堆呢？    堆不释放是否一直占据着内存页？  这样使用已经存在的数据应该是很容易的，因为都在内存中，不用换页

mov   [] 栈内存  全局内存  堆内存   全局是静态固定值  其他应该是个偏移值

对于集合型数据（函数，数组，结构，对象   ），变量名往往是指向数据地址的开头，变量名可以认为是指针  

局部状态下
 该变量名应该是保存在栈中某个基地址（ebp+20），而索引号则是相对于该基地址的偏移
如a[]    每次使用a，就对应着栈地址，   a[0]表示取出栈地址的第一个值

全局数组原理也是一样   a指向的应该是静态的基地址   a[n]是相对于基地址的偏移




但是有个问题，一个是进程切换的时候，别人需要内存，就需要把你的页换出来，然后你又要换回去，如果对方需要大量内存，你的页就都要都换一遍

另外内存碎片多的话，如果要分配新空间，可能在堆查找空间算法上需要一定的困难？没有空间的话需要找到足够大的空间，堆空间找不到足够大的话，  就开辟新内存， 如果实在内存空间不够。。。32位最多只有4G，大了也没办法


某些io函数的缓冲分配



栈也可以动态分配？运行时分配？  sub esp  ebx  此时ebx没算出来
栈本身就是动态分配的啊，bsp位置都是运行时才知道的，没有提前算出地址，而是偏移
esp-4   

什么是静态？可以看成编译时已经出现结果，比如变量的地址值（其实）
什么是动态，就是编译时没结果的，需要执行中运算出来for(100) a=b+c

堆是动态分配？   传入一个变量   调用一个函数  算出一个结果  （可用地址计算）
如果有空位，就插入，如果没空位，就开辟新空间



可以使对象（指针）失去引用的事件？

如果  在堆上分配空间，  然后用指针指过去，最后delete会怎么样？指针仍然会指向该地址，但是数据已经没有


对于c    堆对象   堆数组  new

类型和变量名本来就只是编译器的概念，只是为了方便识别罢了，类型等同于分配内存长度，变量名等同于分配的内存地址。

语法检查中对于类型错误，是否就是越界检查呢？  内存不可以越界


c语言根据定义来确定空间 ，动态语言是如何开空间的？    类型不确定？那空间是如何开的？
如何避免占用其他人的空间？
C语言是类似左值定空间，其他语言有些像右值确定空间  new Array()

c语言的对象，堆对象，和栈对象   栈对象类似于结构体，   数据和方法其实是分离的，他们的关系是在编译时确定的


但也未必，存在类型转换  ，类型转换又是怎么回事？是数值复制吗？  如何实现的
Int a =1+"string"   字符串是个数组，这样转换恐怕不行
sring a=1+"string"
强制类型转换又是什么？  




如何确定内存的长短的
可变长度数组是怎么回事？   对象属性可任意增加是怎么回事？
创建新字符串的时候是怎样的？