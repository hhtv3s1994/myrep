变量的作用：  作为得到的数值    作为控制状态（开关或者选择器），当该量等于多少时则执行后面的语句或者函数     if  switch

类只有被实例化为对象才有意义，才会产生真实的数据――函数只有被调用才会产生局部变量环境……定义本身是没有太多意义的，只要不调用，内存中就不会产生数据，那就没有意义

除了赋值不应该在任何语句中时使用表达式，比如括号内（数组，函数，对象属性）――而应该把表达式和调用命名为变量，调用函数使用get-reutrn型函数赋值给变量

括号内不应该存在魔数，包括数组索引，

传地址参数和直接引用全局变量的区别，解除对特定变量名的依赖，可以传入任何参数要实现set型函数，方便做成api给人调用……java是通过对象参数来set外部数据，比如传入集合，字节数组等

if else 和if if的区别    switch break  和没有break的区别……会不断进行判断，执行所有语句，如果使用break或者return就能跳出判断……万一后面存在默认项和非判断语句，有可能导致执行了不想执行的语句，产生矛盾……可以多写if return  

除非程序需求（比如状态机），否则不应该随便修改循环流的控制变量，如i，比如比较数n，数组长度length，指针指向等

类型是为了给编译器提示的值的长度，先定义好某种类型的长度，值可能保存在堆上或者是栈上，栈上也可能只保存了指针引用，静态语言会维护变量表，带上变量类型，方便查询……但是字符串和数组是用其他方式保存长度的，有的语言中两者属于对象，直接用属性保存，有的语言用终止符……也可能这个长度不保存在内存中，而保存在编译环境中   首地址，长度

动态数组：relloc    new  delete 重新分配   字符串处理 文件读写  网络请求都是很常见的，用字符数组，字节数组也是很常见的需求……c等语言中，使用传入地址来直接修改外部量，或者传入数组参数来接收生成值，或者读取的外部值也是很常见的

变量就是可变动的量，在动态语言中连对象类型都可以变，通过变动值    并通过重复循环，或者反复使用来引导程序的流向。。。可能存在同一个函数调用同一个变量，或者对象，或者集合，结果内容不同的情况     变量或者变量集合的改变，导致程序连续执行时的执行流改变
改变流向的方式，控制if 控制for 控制break  return error   控制调用的参数变动  控制返回值的变动  控制中间变量的变动，控制集合的长度和内容
而不同的执行流也可以改变原来的变量

全局变量：未封装，可以直接被调用的下层模块直接访问修改的量，无需用参数形式传入――原则上传参只能get，不能set，   set一般是穿透作用域进行的 （访问全局变量，或者上层局部，上层的public属性）   

相对全局变量：在当前调用环境中存在的变量，可以直接被调用的函数内部访问到的，不需要通过参数传入的。包括调用函数所在对象的属性，调用函数自己的局部变量   可以不传入参数就被被调函数访问到。。。。  其实只要在一个作用域中，该作用域和上层作用域的所有变量都能被被调函数直接访问，这都是全局……所以规范不是不定义全局，而是下层函数不应该轻易访问全局，除非是上层传入，只有本层函数才能访问自己作用域的变量     上层的变量修改应该通过自身的接口实现，或者用单纯的同层赋值语句

函数内部的局部变量 是直接赋值语句，还是 再用个穿透作用域的set函数调用？ 传参是无法set的，必须直接访问局部变量 f(){ var a ;  setA(number);  } ――如果认为函数是模块，同层定义的函数应该是平行关系，而函数内定义的函数是定义上的上下层关系 。用平行的函数穿透作用域set显得不自然，而用上下嵌套定义的函数访问局部变量是比较自然的  
定义中访问外层局部和调用中访问外层局部的区别

如果使用传参函数，无论干什么都应该是只读不改参数。（不对参数重赋值，不用参数当成中转量）


在对象或者集合中，存在匿名的变量，比如数组元素（另一个角度上可以认为数组索引就是变量名） 匿名函数，  这些匿名的变量和函数也是可以动态改变的

对于集合：  存在对象集合，如对象数组   存在函数集合   数组和对象、集合都可以动态添加，修改，删除其中包含的变量   从而达到动态控制的目的    这个在反复进行的 遍历过程中很常见，比如游戏中不断遍历某个对象数组 判断碰撞，判断Id等   不断遍历消息队列 不断检查监听者判断Id type  这种两层循环+动态修改的模式很有用

集合类型的变量在动态性方面是很有用的

对象的组合方式，通过构造传入，通过set，或者set类型的方法由参数传入，通过全局穿透传入 通过工厂方法

对象属性无论如何不要用外部方法调用，而应该通过自己的方法来修改

关于动态变量名的思考， 用变动的字符串来生成变量名，然后访问。指针，属性名，数组序号，关联数组哈希表――这些变动的字符串可以使用读表，遍历数组，字符串循环拼接，数字序号自增长，逻辑查询表数组来实现    这样动态生成想要的属性，也可以反向找到某种规律属性


作为比较界限    作为计数器 时间 次数 索引  有序id
作为临时缓存   

在循环程序和自动执行过程中使用控制状态是非常好的

关于全局变量的处理――把所有直接修改或者获取全局变量的处理都封装为单独的函数，使用比较好的命名方法，最好不要硬编码 getGlobal(){}  setGlobal(x)  
所有全局变量相关：赋值，获取，设置，都应该封为函数再使用

另一种想法是使用传参return函数，再赋值给变量的方式，减少了耦合――全局变量不要直接用表达式赋值

封装数据和处理 到函数是避免耦合的最好办法――增加中间层，不用改引用数据的多处，只用调用函数的一处――方便debug，查错  增加功能，修改功能

多用临时变量，参数和一次性返回值，少用需要持续修改的变量（一次循环一个变量应该只赋值一次，赋值多次可以用临时变量中转）

不要直接给参数赋值修改 。参数应该只读不改（）但是可以修改指针的值（只改值不改地址），变量和集合的内部元素值

不要直接在表达式中使用字面量值  1 2 3  ""  不应该在括号中使用魔数。比如数组索引，函数参数，对象属性

不要不赋值 给变量  就直接使用 间接值   比如直接传数字，字符串字面量/常量 的实参 ，在if中不要使用复杂表达式  函数调用中不传表达式 不传调用函数返回值（可以传匿名参数，但是最好还是命名）

任何非直接得到的值都应该接收再使用

间接值包括   函数的返回值a.fun()  func()   对象的属性a.b   运算后得到的值，如字符串拼接，加减乘除   这些表达式的值都应该用一个新变量接收
   
获取值的方式无非get    get是return值

和set
set的形式：设置全局变量，设置对象属性， 设置其他对象属性  修改传入的参数，以及参数中的值
加入  移除  修改    前提：遍历

直接修改参数传入的对象的引用是无效的，因为是值传递

增  删  改都是set  查是比较     如果有确定的索引或者key才能增删改，不然就必须使用查
但也有特殊的，利用最后游标cusor实现 push pop这样的特殊增删   